/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

package proxmoxtf

import (
	"fmt"
	"github.com/danitso/terraform-provider-proxmox/proxmox"
	"github.com/hashicorp/terraform/helper/schema"
	"github.com/hashicorp/terraform/helper/validation"
	"net/url"
	"strings"
)

const (
	mkResourceVirtualEnvironmentClusterOptionsBandwidthLimit = "bandwidth_limit"
	mkResourceVirtualEnvironmentClusterOptionsConsole        = "console"
	mkResourceVirtualEnvironmentClusterOptionsEmailFrom      = "email_from"
	mkResourceVirtualEnvironmentClusterOptionsFencing        = "fencing"
	mkResourceVirtualEnvironmentClusterOptionsHttpProxy      = "http_proxy"
	mkResourceVirtualEnvironmentClusterOptionsKeyboard       = "keyboard"
	mkResourceVirtualEnvironmentClusterOptionsLanguage       = "language"
	mkResourceVirtualEnvironmentClusterOptionsMacPrefix      = "mac_prefix"
	mkResourceVirtualEnvironmentClusterOptionsMaxWorkers     = "max_workers"
)

func resourceVirtualEnvironmentClusterOptions() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			mkResourceVirtualEnvironmentClusterOptionsBandwidthLimit: {
				Type:        schema.TypeMap,
				Description: "Set bandwidth/io limits various operations (must be in bytes).",
				Optional:    true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"clone": {
							Type:     schema.TypeInt,
							Optional: true,
						},
						"default": {
							Type:     schema.TypeInt,
							Optional: true,
						},
						"migration": {
							Type:     schema.TypeInt,
							Optional: true,
						},
						"move": {
							Type:     schema.TypeInt,
							Optional: true,
						},
						"restore": {
							Type:     schema.TypeInt,
							Optional: true,
						},
					},
				},
			},
			mkResourceVirtualEnvironmentClusterOptionsConsole: {
				Type:        schema.TypeString,
				Description: "Set the default Console Viewer",
				Optional:    true,
				ValidateFunc: validation.StringInSlice([]string{
					"applet",
					"vv",
					"html5",
					"xtermjs",
				}, false),
			},
			mkResourceVirtualEnvironmentClusterOptionsEmailFrom: {
				Type:        schema.TypeString,
				Description: "Specify email address to send notifications from",
				Optional:    true,
				ValidateFunc: func(i interface{}, k string) (ws []string, es []error) {
					v, ok := i.(string)
					if !ok {
						es = append(es, fmt.Errorf("expected type of %s to be string", k))
						return
					}

					idx := strings.Count(v, "@")
					if idx != 1 {
						es = append(es, fmt.Errorf("expected %s to be an email", v))
					}

					return
				},
			},
			mkResourceVirtualEnvironmentClusterOptionsFencing: {
				Type:        schema.TypeString,
				Description: "Set the fencing mode of the HA cluster. Hardware mode needs a valid configuration of fence devices in /etc/pve/ha/fence.cfg. With both all two modes are used.",
				Optional:    true,
				ValidateFunc: validation.StringInSlice([]string{
					"watchdog",
					"hardware",
					"both",
				}, false),
			},
			mkResourceVirtualEnvironmentClusterOptionsHttpProxy: {
				Type:        schema.TypeString,
				Description: "Specify external http proxy which is used for downloads (example: 'http://username:password@host:port/')",
				Optional:    true,
				ValidateFunc: func(ov interface{}, t string) (ws []string, es []error) {
					v, ok := ov.(string)
					if !ok {
						es = append(es, fmt.Errorf("expected type of %s to be string", t))
						return
					}

					u, err := url.ParseRequestURI(v)
					if err != nil || u.Scheme == "" || u.Host == "" {
						es = append(es, fmt.Errorf("http_proxy attribute must be a URL, found %s", v))
					}
					return
				},
			},
			mkResourceVirtualEnvironmentClusterOptionsKeyboard: {
				Type:        schema.TypeString,
				Description: "Default keyboard layout for vnc server.",
				Optional:    true,
				ValidateFunc: validation.StringInSlice([]string{
					"de", "de-ch", "da", "en-gb", "en-us", "es", "fi", "fr",
					"fr-be", "fr-ca", "fr-ch", "hu", "is", "it", "ja", "lt",
					"mk", "nl", "no", "pl", "pt", "pt-br", "sv", "sl", "tr",
				}, false),
			},
			mkResourceVirtualEnvironmentClusterOptionsLanguage: {
				Type:        schema.TypeString,
				Description: "Default GUI language.",
				Optional:    true,
				ValidateFunc: validation.StringInSlice([]string{
					"ca", "da", "de", "en", "es", "eu", "fa", "fr", "he", "it", "ja",
					"nb", "nn", "pl", "pt_BR", "ru", "sl", "sv", "tr", "zh_CN", "zh_TW",
				}, false),
			},
			mkResourceVirtualEnvironmentClusterOptionsMacPrefix: {
				Type:        schema.TypeString,
				Description: "Prefix for autogenerated MAC addresses.",
				Optional:    true,
			},
			mkResourceVirtualEnvironmentClusterOptionsMaxWorkers: {
				Type:        schema.TypeInt,
				Description: "Defines how many workers (per node) are maximal started  on actions like 'stopall VMs' or task from the ha-manager.",
				Optional:    true,
				ValidateFunc: validation.IntAtLeast(1),
			},
		},
		Create: resourceVirtualEnvironmentClusterOptionsCreate,
		Read:   resourceVirtualEnvironmentClusterOptionsRead,
		Update: resourceVirtualEnvironmentClusterOptionsUpdate,
		Delete: resourceVirtualEnvironmentClusterOptionsDelete,
	}
}

func resourceVirtualEnvironmentClusterOptionsCreate(d *schema.ResourceData, m interface{}) error {
	err := resourceVirtualEnvironmentClusterOptionsUpdate(d, m)

	if err != nil {
		return err
	}

	d.SetId("cluster_options")

	return nil
}

func resourceVirtualEnvironmentClusterOptionsGetUpdateBody(d *schema.ResourceData, m interface{}) (*proxmox.VirtualEnvironmentClusterOptionsUpdateRequestBody, error) {
	body := &proxmox.VirtualEnvironmentClusterOptionsUpdateRequestBody{}
	if d.HasChange(mkResourceVirtualEnvironmentClusterOptionsBandwidthLimit) {
		bandwidthLimits := d.Get(mkResourceVirtualEnvironmentClusterOptionsBandwidthLimit).(map[string]interface{})

		bwLimitList := make([]string, 0, len(bandwidthLimits))
		for op, limit := range bandwidthLimits {
			bwLimitList = append(bwLimitList, op+"="+limit.(string))
		}
		bwLimit := strings.Join(bwLimitList, ",")

		body.BandwidthLimit = &bwLimit
	}
	if d.HasChange(mkResourceVirtualEnvironmentClusterOptionsConsole) {
		console := d.Get(mkResourceVirtualEnvironmentClusterOptionsConsole).(string)
		body.Console = &console
	}
	if d.HasChange(mkResourceVirtualEnvironmentClusterOptionsEmailFrom) {
		emailFrom := d.Get(mkResourceVirtualEnvironmentClusterOptionsEmailFrom).(string)
		body.EmailFrom = &emailFrom
	}
	if d.HasChange(mkResourceVirtualEnvironmentClusterOptionsFencing) {
		fencing := d.Get(mkResourceVirtualEnvironmentClusterOptionsFencing).(string)
		body.Fencing = &fencing
	}
	if d.HasChange(mkResourceVirtualEnvironmentClusterOptionsFencing) {
		httpProxy := d.Get(mkResourceVirtualEnvironmentClusterOptionsHttpProxy).(string)
		body.HttpProxy = &httpProxy
	}
	if d.HasChange(mkResourceVirtualEnvironmentClusterOptionsKeyboard) {
		keyboard := d.Get(mkResourceVirtualEnvironmentClusterOptionsKeyboard).(string)
		body.Keyboard = &keyboard
	}
	if d.HasChange(mkResourceVirtualEnvironmentClusterOptionsLanguage) {
		language := d.Get(mkResourceVirtualEnvironmentClusterOptionsLanguage).(string)
		body.Language = &language
	}
	if d.HasChange(mkResourceVirtualEnvironmentClusterOptionsMacPrefix) {
		macPrefix := d.Get(mkResourceVirtualEnvironmentClusterOptionsMacPrefix).(string)
		body.MacPrefix = &macPrefix
	}

	if d.HasChange(mkResourceVirtualEnvironmentClusterOptionsMaxWorkers) {
		maxWorkers := d.Get(mkResourceVirtualEnvironmentClusterOptionsMaxWorkers).(int)
		body.MaxWorkers = &maxWorkers
	}

	return body, nil
}

func resourceVirtualEnvironmentClusterOptionsRead(d *schema.ResourceData, m interface{}) error {
	config := m.(providerConfiguration)
	veClient, err := config.GetVEClient()

	if err != nil {
		return err
	}

	opts, err := veClient.GetClusterOptions()

	if err != nil {
		return err
	}

	bwLimitOptions := strings.Split(opts.BandwidthLimit, ",")
	bwlimit := make(map[string]string, len(bwLimitOptions))

	for _, opt := range bwLimitOptions {
		if opt == "" {
			continue
		}

		optSplit := strings.SplitN(opt, "=", 2)
		bwlimit[optSplit[0]] = optSplit[1]
	}

	optMap := map[string]interface{}{
		mkResourceVirtualEnvironmentClusterOptionsBandwidthLimit: bwlimit,
		mkResourceVirtualEnvironmentClusterOptionsConsole:        opts.Console,
		mkResourceVirtualEnvironmentClusterOptionsEmailFrom:      opts.EmailFrom,
		mkResourceVirtualEnvironmentClusterOptionsFencing:        opts.Fencing,
		mkResourceVirtualEnvironmentClusterOptionsHttpProxy:      opts.HttpProxy,
		mkResourceVirtualEnvironmentClusterOptionsKeyboard:       opts.Keyboard,
		mkResourceVirtualEnvironmentClusterOptionsLanguage:       opts.Language,
		mkResourceVirtualEnvironmentClusterOptionsMacPrefix:      opts.MacPrefix,
		mkResourceVirtualEnvironmentClusterOptionsMaxWorkers:     opts.MaxWorkers,
	}

	for key, val := range optMap {
		err = d.Set(key, val)

		if err != nil {
			return err
		}
	}

	return nil
}

func resourceVirtualEnvironmentClusterOptionsUpdate(d *schema.ResourceData, m interface{}) error {
	config := m.(providerConfiguration)
	veClient, err := config.GetVEClient()

	if err != nil {
		return err
	}

	body, err := resourceVirtualEnvironmentClusterOptionsGetUpdateBody(d, m)

	if err != nil {
		return err
	}

	err = veClient.UpdateClusterOptions(body)

	if err != nil {
		return err
	}

	return resourceVirtualEnvironmentClusterOptionsRead(d, m)
}

func resourceVirtualEnvironmentClusterOptionsDelete(d *schema.ResourceData, m interface{}) error {
	config := m.(providerConfiguration)
	veClient, err := config.GetVEClient()

	if err != nil {
		return err
	}

	err = veClient.DeleteClusterOptions(&proxmox.VirtualEnvironmentClusterOptionsDeleteRequestBody{
		Delete: proxmox.DeleteOptions{
			mkResourceVirtualEnvironmentClusterOptionsBandwidthLimit,
			mkResourceVirtualEnvironmentClusterOptionsConsole,
			mkResourceVirtualEnvironmentClusterOptionsEmailFrom,
			mkResourceVirtualEnvironmentClusterOptionsFencing,
			mkResourceVirtualEnvironmentClusterOptionsHttpProxy,
			mkResourceVirtualEnvironmentClusterOptionsKeyboard,
			mkResourceVirtualEnvironmentClusterOptionsLanguage,
			mkResourceVirtualEnvironmentClusterOptionsMacPrefix,
			mkResourceVirtualEnvironmentClusterOptionsMaxWorkers,
		},
	})

	if err != nil {
		return err
	}

	d.SetId("")

	return nil
}
